# All The Things Client
All The Things Client is the front end for the All The Things application. This application allows individuals to upload their files and share them with others in the All The Things community in a secure environment.

Individuals must sign up in order to be part of the All The Things community. All The Things members may download and view all uploaded files. Only file owners may update or delete their files.

# Femme Squad Plus One Developers
* Nari Savanorke-Joyce
* Amanda Abbott
* Jim Moody
* Angela Mashlan

# Links
* [All The Things URL](https://femme-squad-plus-one.github.io/all-the-things-client/)
* [All The Things API Repository](https://github.com/femme-squad-plus-one/all-the-things-api)
* [All The Things API](https://guarded-cliffs-28165.herokuapp.com/)

# Future Enhancements
* Custom folder paths set by the user
* Ability to grant update permission to specific users
* Ability to tag and display uploaded items by tag groups


## Dependencies

Install with `npm install`.

-   [Webpack](https://webpack.github.io)
-   [Bootstrap](http://getbootstrap.com)
-   [Handlebars.js](http://handlebarsjs.com)
-   Moment


## Installation

1.  Fork and clone this repository.
1.  Install dependencies with `npm install`.

## Structure

* Dependencies are stored in [`package.json`](package.json).

* Do not configure `grunt` packages directly in the
[`Gruntfile.js`](Gruntfile.js). Instead, store configurations in the
[`grunt`](grunt) directory. You won't need a top-level key, since that's
generated by the `Gruntfile.js` based on the filename of the configuration
object stored in the `grunt` directory.

* Developers should store JavaScript files in [`assets/scripts`](assets/scripts).

* The "manifest" or entry-point is
[`assets/scripts/index.js`](assets/scripts/index.js). In general, only
application initialization goes in this file. It's normal for developers to
start putting all code in this file, but encourage them to break out different
responsibilities and use the `require` syntax put references where they're
needed.

* Developers should set `config.apiOrigins.production` (and
`config.apiOrigins.development` if it differs from the default).  With
`apiOrigins` set, developers may rely on `config.apiOrigin` as the base for API
URLs.

* Developers should store styles in [`assets/styles`](assets/styles) and load them
from [`assets/styles/index.scss`](assets/styles/index.scss).

* Developers should use [getFormFields](forms.md) to retrieve form data to send to
an API unless it is multipart/form data which developers should then use the FormData interface.

* To deploy a browser-template based SPA, run `grunt deploy`.

## Project Development Approach

The members of Femme Squad Plus One took a very organized and agile-like approach. We started with white-boarding the user stories for the project prompt and quickly moved to white-boarding the wireframes and then the team task list (see details below for user stories, wireframes, and the daily task boards).

We pair-programmed with one team working on the backend and the other team working on the front end. Each pair switched off being the primary coder: sometimes switching off with completing a major feature and sometimes switching while on the same branch. See the Git section below for more details on the Git workflow.

We were very collaborative. The suggested roles of Project Lead, Front End Lead, etc. didn't feel natural. It turned out that we didn't really need them.

## Team Restrospective

This section captures individual team member's retrospectives on the most challenging part and their favorite part doing this team project.

### Nari

Challenges: I had a hard time debugging the PATCH request, especially when it came to implementing modals. It also took me a very long time to refactor the user authentication code and fit the existing code structure.

Favorite Part: Learning from my teammates! I was exposed to several new techniques during this project - more advanced Bootstrap, modals, AWS, multer, and sorting through Git conflicts. I really benefited from pair programming and enjoyed collaborating with others.

### Amanda

Challenges: One of the most challenging parts of the project for me was adopting a file organization that I hadnâ€™t previously used. For this project, we set up all the page views using handlebars which was not the route I had gone for my first two projects. It was more to think through in the beginning because I had to think of how, what and when the page was rendering things in order to add functions in the correct place. After I learned this style of organization, I really liked it because I could easily separate out the html segments versus having a large index.html file. It was also easier for when multiple people wanted to work on the different sections.

Favorite Part: I really liked working in a team and the pair programming. It was fun to learn from each other. During pairing, it was nice to be able to ask my partner questions without feeling like I was interrupting their work. I also liked being able to collaborate on design and talk through the requirements with a team.

### Jim

Challenges: All of it.  Mostly just figuring out how the heck folders would work.  I never thought they would be so complicated.

Favorite Part: Seeing how other people approach the same problem with different ideas that I would never have thought of.


### Angela

Challenges: Not really understanding some of the requirements--like the requirement for `maintaining folder structures`. In the end, the team agreed on what *we* thought were the requirements, but until that point, I was worried.

Favorite Part: I really enjoyed working with such a collaborative team. I really liked pair programming and being able to talk through ideas. I learned different ways to make better code through my experiences from this project.


## User Stories
As a user, I want to:
1. Create an account
2. Sign in with my account name and password
3. Be able to change my password
4. Be able to sign out of my account
5. See all files uploaded to the app
    1. See them by category/tag
    2. See who owns the files
    3. Download any file regardless of owner

As an owner, I want to:
1. Upload/save a file to my own account
2. Create/update/delete my own file structure for my saved files
3. Delete a file from my own account
4. Make updates to an existing file
5. Assign tag(s) to my files (at creation, at any time after creation)
6. Know/see when my file was uploaded/created
7. Know/see when my file was modified

## Wireframes
[All The Things Wireframes](https://docs.google.com/presentation/d/1v__-Fl0g3-yYKhrk0qjQxei9ILzVg5HOtj_aT2rcP7A/edit?usp=sharing)

## Planning
[All The Things Daily Task Boards](https://docs.google.com/presentation/d/1ZinC_mRzicxH4_CNPhSjqzW2rxRGI5fuzDcquraJXtc/edit?usp=sharing)

## Git
The team decided early on to use the common workflow of having a master and a dev branch. Feature branches were checked out of dev and merged into dev. Major releases were managed through pull requests from dev into master.

The following git workflow was followed:
1. Checkout from dev branch
2. Push from local to remove
3. Create pull request on git server into dev from feature branch
4. Team reviews and approves pull request
5. Team member merges to dev
6. Everyone pulls from remote to local dev

When team was ready to deploy to production, the following workflow was followed:
1. Team member creates pull request on git server into master from dev
2. One or more team members reviews and approves the request
3. Team member completed the merge
4. Everyone pulls from remote to local master
5. Team member `grunt deploys` to production

Pull requests were reviewed and approved by the entire team as much as we could (after hours was harder due to team member availability).

The team tried different merge scheduling approaches. On the first day, we had decided to do merge/code reviews at 11:30 and 4:00. When we finished a feature branch, we branched off of that branch and submitted pull requests for all of them as we completed them. At the 11:30 and 4:00 merge, we learned that subsequent pull requests needed to be rebased before the merge so that we could avoid duplicate commit messages (see Git section below for more details on Git workflow).

The next day we tried getting the team to do merge/code reviews on a ad-hoc basis. This was a little better, but we still couldn't avoid rebasing and also having to resolve merge conflicts.

The strict adherence to the git workflow allowed the team to rollback code from production rather easily. One feature had caused an unexpected defect in production. Luckily, the root cause was identified as the last feature merged to the dev branch. To roll back that code, the team did a rollback of master by one commit, force pushed that change up to the server, did a rollback of dev by one commit (the latest feature branch), force pushed that change up to the server, and then created a new pull request into master from dev.

[All The Things Git Graph](./git-output-master.txt)
